ZGC сборщик мусора
![img](./ZGC-2048.png)

G1 сборщик мусора
![img](./G1-2048.png)

<table>
<caption>Сборщики мусора (time - время в секундах до падения тестировщика при разных размерах кучи,
критическая точка - время в секундах)</caption>
<tr><th>GC</th><th>256m time</th><th>2048m time</th><th>критическая точка</th></tr>
<tr><td>G1</td><td>65</td><td>540</td><td>408</td></tr>
<tr><td>ZGC</td><td>51</td><td>417</td><td>380</td></tr>
</table>

Попробовал отследить начало каких-то изменений в поведении сборщиков (критическая точка):<br>
для G1 - первая дефрагментация Old поколения (случилось, когда память кучи уже была занята)<br>
для ZGC - первое событие "High Usage" (случилось, когда размер ZHeap увеличился до размера кучи)<br>
"High Usage" в ZGC из <a href="https://bugs.openjdk.java.net/browse/JDK-8224185">openjdk</a>  Perform GC if the amount of free memory is 5% or less.

Преимущество G1 сборщика перед прежними поколениями заключается в том, что он уделяет дефрагментации установленные моменты времени.
По логу видно, что в период, когда необходимости в новой памяти нет (файлы приложены), он занимается young областями. Когда в памяти появляется существенная нужда, начинается уничтожение Old поколения.

Сборщик ZGC появился позднее. А с версии Java 15 можно использовать его без ключа -XX:+UnlockExperimentalVMOptions.
ZGC берёт полный контроль над Кучей, отсюда и лестницеподобный график занимаемой памяти в VisualVm (У ZGC определена своя область кучи, ZHeap, приложил в логах). У ZGC может в onlinetime дефрагментизировать память и посредством специальных барьеров, при необходимости давать указатели приложению.

По сравнению с G1 на моём ноутбуке у ZGC есть небольшое преимущество. В случае кучи в 2048Mb, порядка минуты. Но G1 не преодолел ни разу в скорости, на моём тесте, ZGC сборщик ни на одном размере кучи.